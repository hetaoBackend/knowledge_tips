---


---

<h1 id="数据结构--堆（heap）">数据结构–堆（Heap）</h1>
<ul>
<li>Heap是一种数据结构具有一下的特点：
<ol>
<li>完全二叉树</li>
<li>heap中存储的值是偏序的</li>
</ol>
</li>
<li>Min-heap：父节点的值小于或等于子节点的值；</li>
<li>Max-heap：父节点的值大于或等于子节点的值；</li>
</ul>
<h2 id="堆的存储">1. 堆的存储</h2>
<p>一般都用数组来表示堆，i节点的父节点下标就为(i-1)/2。<br>
它的左右子节点下标分别为2 * i + 1和2 * i + 2。如第0个节点左右节点下标分别为1和2。</p>
<h2 id="堆的操作">2. 堆的操作</h2>
<ul>
<li>insert<br>
插入一个元素：新的元素被加入到heap的末尾，然后更新树以恢复堆的次序。<br>
每次插入都是将新数据放在数组最后。可以发现从这个新数据的父节点到根节点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中， 这就类似于直接插入排序中将一个数据并入有序区间中。</li>
<li>RemoveMax<br>
按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根节点，然后再从根节点开始进行一次从上往下的调整。调整时先在左右儿子节点中找最大的，如果父节点比这个最小的子节点还大说明不需要调整了，反之将父节点和它交换后再考虑后边的节点。相当于一个根节点的“下沉”过程。</li>
<li>buildHeap堆化数组<br>
对于叶子节点，不用调整次序，根据满二叉树的性质，叶子节点比内部节点的个数多1，所以i=n/2-1，不用从n开始。</li>
<li>堆排序<br>
堆建好以后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</li>
</ul>

